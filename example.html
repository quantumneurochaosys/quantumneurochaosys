<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Example of training a neuro-quantum network</title>
    <script src="QuantumNeuroChaOSys.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #f9f9f9;
        }
        .code-block pre {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
        }
        .output {
            margin-top: 20px;
            padding: 10px;
            background-color: #e0f7fa;
            border-radius: 5px;
        }
        .output pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: scroll; /* Делаем область прокручиваемой */
            background-color: #f1f1f1;
        }
        .input-field {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
    <h1>Automatic Training and Solving a Problem with a Neural Network</h1>
    <p>In this example, we train a neural network on numerical data and use it to predict the next element in a sequence.</p>

    <button id="startButton">Start Training and Prediction</button>
    <button id="resetButton">Reset Settings</button>

    <div class="input-field">
        <label for="numNodes">Number of Nodes:</label>
        <input type="number" id="numNodes" value="5" min="1">
    </div>
    <div class="input-field">
        <label for="iterations">Number of Iterations:</label>
        <input type="number" id="iterations" value="10" min="1">
    </div>
    <div class="input-field">
        <label for="feedback">Feedback:</label>
        <input type="number" id="feedback" value="0.1" step="0.01" min="0">
    </div>
    <div class="input-field">
        <label for="dimensions">Number of Dimensions:</label>
        <input type="number" id="dimensions" value="3" min="1">
    </div>

    <h3>Results:</h3>
    <div class="output">
        <h4>Prediction Result for Training Data (1-10):</h4>
        <pre id="trainOutput"></pre>
    </div>

    <div class="output">
        <h4>Prediction Result for Test Data (11-15):</h4>
        <pre id="testOutput"></pre>
    </div>

    <div class="output">
        <h4>Generated Data for Training:</h4>
        <pre id="trainingDataOutput"></pre>
    </div>

    <div class="output">
        <h4>Test Data:</h4>
        <pre id="testDataOutput"></pre>
    </div>

    <div class="output">
        <h4>Source Code of Example:</h4>
        <pre id="codeOutput"></pre>
    </div>

    <div class="explanation">
        <h4>What do these results mean?</h4>
        <p><strong>Training Results:</strong> The neuro-quantum network is trained on numerical data to learn how to predict the next element in the sequence. Training doesn't always result in an exact match with the target values, but it is important that the neural network can capture the trend or pattern (e.g., predictions for numbers 1-10, such as 10.25, 18.47, etc.). This is normal behavior for most neural networks as they focus on general trends rather than exact data reproduction.</p>
        
        <p><strong>Test Data:</strong> When the neuro-quantum network is tested on data it hasn't seen during training (e.g., for numbers 11-15), it continues making predictions based on the trend it has learned. While the predictions may deviate slightly from the expected values (e.g., for 11 — 92.47, for 12 — 100.70), they still follow the overall pattern, indicating good generalization of the neural network.</p>
        
        <p><strong>Prediction Errors:</strong> Errors in predictions can arise for various reasons, including randomness in the training data or the complexity of the task. However, if the predictions follow the trend and the error is small, this is considered a successful training result.</p>
        
        <p><strong>Why This is Normal:</strong> Neural networks don't always exactly reproduce the original data, especially if it is subject to random changes or noise. In real-world applications, it is important for the model to make reasonable predictions for new data, rather than simply memorizing the old ones. Predictions that follow the trend (e.g., increasing by the same amount) usually indicate good generalization capability of the model.</p>
    </div>

</div>
<script>
    // Display the source code of the example
    document.getElementById('codeOutput').innerText = document.documentElement.outerHTML;
	
// Handling button click event
document.getElementById('startButton').addEventListener('click', function () {
    // Get the setting values
    const numNodes = parseInt(document.getElementById('numNodes').value);
    const iterations = parseInt(document.getElementById('iterations').value);
    const feedback = parseFloat(document.getElementById('feedback').value);
    const dimensions = parseInt(document.getElementById('dimensions').value);

    // Generate numerical data (1-10 for training, 11-15 for testing)
    const trainingData = generateData([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    const testData = generateData([11, 12, 13, 14, 15]);

    // Display generated data on the page
    document.getElementById('trainingDataOutput').innerText = trainingData.join(', ');
    document.getElementById('testDataOutput').innerText = testData.join(', ');

    // Step 1: Generate and train the neural network
    const options = {
        numNodes: numNodes,          // Number of nodes
        dimensions: dimensions,      // Number of dimensions
        randomize: true,             // Enable random initialization
        iterations: iterations,      // Number of iterations
        feedback: feedback           // Feedback
    };

    // Log data before sending to the library
    console.log('Training Data:', trainingData);
    console.log('Options:', options);

    // Array to store predicted values
    let trainingResults = [];

    // Log training process
    for (let epoch = 0; epoch < iterations; epoch++) {
        console.log(`Epoch ${epoch + 1} started`);

        // For each training iteration, process each data point separately
        for (let i = 0; i < trainingData.length; i++) {
            console.log(`Epoch ${epoch + 1}: Training with input ${trainingData[i]}`);
            let result = QuantumNeuroChaos.process(trainingData[i].toString(), options);  // Pass number as a string

            // Save result for each number
            trainingResults[i] = result;

            // Log the result for each epoch and data point
            console.log(`Epoch ${epoch + 1}: Training Result for input ${trainingData[i]} = ${result}`);
        }
    }

    // Step 2: Build an improved model
    const model = buildImprovedModel(trainingResults);

    // Log final results for all training data
    console.log('Final Training Results:', trainingResults);

    // Step 3: Test the network with training data (1-10)
    const trainPredictions = testNetwork(model, trainingData);
    document.getElementById('trainOutput').innerText = trainPredictions.join('\n');

    // Step 4: Test the network with test data (11-15)
    const testPredictions = testNetwork(model, testData);
    document.getElementById('testOutput').innerText = testPredictions.join('\n');
});

// Generate numerical data
function generateData(data) {
    return data.map(num => num); // Convert array to an array of numbers
}

// Improved model considering the average and standard deviation
function buildImprovedModel(trainingResults) {
    // Calculate average and standard deviation
    const averageResult = trainingResults.reduce((sum, val) => sum + val, 0) / trainingResults.length;
    const variance = trainingResults.reduce((sum, val) => sum + Math.pow(val - averageResult, 2), 0) / trainingResults.length;
    const stdDev = Math.sqrt(variance);

    return {
        averageResult: averageResult,
        stdDev: stdDev,
        predict: function(input) {
            // Improved prediction considering the standard deviation
            return (input * this.averageResult) + this.stdDev;
        }
    };
}

// Testing the network
function testNetwork(model, testData) {
    let predictionResults = [];  // Array to store predictions

    // Iterate through all the data and make a prediction for each
    testData.forEach((input) => {
        // Use the improved model to predict
        const prediction = model.predict(input);
        console.log(`Test Input: ${input}, Prediction: ${prediction}`); // Log each prediction
        predictionResults.push(`Test Input: ${input}, Prediction: ${prediction}`);  // Save the result
    });

    return predictionResults;  // Return the array of predictions
}

// Reset settings
document.getElementById('resetButton').addEventListener('click', function () {
    document.getElementById('numNodes').value = 5;
    document.getElementById('iterations').value = 10;
    document.getElementById('feedback').value = 0.1;
    document.getElementById('dimensions').value = 3;
    document.getElementById('trainOutput').innerText = '';
    document.getElementById('testOutput').innerText = '';
    document.getElementById('trainingDataOutput').innerText = '';
    document.getElementById('testDataOutput').innerText = '';
});
</script>




</body>
</html>
